# 进程和线程区别
"进程是分配资源的最小单位,线程是CPU调度的最小单位"

在只有进程的时候，进程间的调度是要这样的，加载进程A的上下文->cpu执行进程A->保存进程A的上下文->加载进程B的上下文
这里的进程上下文包括：
1. 用户级上下文： 正文、数据、用户堆栈以及共享存储区； 
2. 寄存器上下文： 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)； 
3. 系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈

切换上下文的代价是比较大的，上下文切换后一些缓存就用不了了比如TLB。后来就搞了个线程出来，让多个线程共享一个进程的某些上下文，这样线程切换的时候就不需要，切换这些共享的上下文，减少了切换时间，增加了cpu的利用率。

线程共享了进程的：
1. 虚拟空间，包括代码，data，bss，堆
2. 自己寄存器值，线程的栈，线程ID，错误码，信号屏蔽码

一个线程崩溃了(触发SIGSEGV，且没有捕捉)，这个进程内的所有线程都崩溃了。
比如一个线程向非法地址读取或写入，无法确认这个是否会影响其他线程，只能崩溃。

# 为什么进程切换比线程切换慢
1. 切换页目录以使用新的地址空间

2. 切换内核栈和硬件上下文

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。

切换的性能消耗：

1. 线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

2. 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题

#进程和线程的使用场景

线程的使用场景；
各个job需要频繁的通信或者切换，有数据需要修改，有明显的IO等待的job，比如ui等待io交互
频繁的创建和销毁job。

进程的使用场景
需要稳定的运行，确保健壮性，